<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Adobe Stock Metadata & Image Prompt Generator (Groq Vision)</title>
  <style>
    :root { color-scheme: dark; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 1200px;
      margin: 24px auto;
      padding: 0 16px 32px;
      background: #020617;
      color: #e5e7eb;
    }
    h1 { text-align: center; margin-bottom: 8px; }
    .subtitle {
      text-align: center;
      font-size: 13px;
      color: #9ca3af;
      margin-bottom: 20px;
    }
    .card {
      background: #020617;
      border-radius: 14px;
      padding: 16px 18px 20px;
      border: 1px solid #1e293b;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.5);
    }
    label {
      display: block;
      font-size: 13px;
      margin-bottom: 4px;
      color: #9ca3af;
    }
    input[type="password"],
    input[type="file"],
    select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #1f2933;
      background: #020617;
      color: #f9fafb;
      font-size: 14px;
      box-sizing: border-box;
      margin-bottom: 8px;
    }
    input[type="file"] { padding: 6px 4px; }
    button {
      background: #22c55e;
      border: none;
      color: #022c22;
      padding: 9px 14px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #1f2937;
    }
    button:disabled { opacity: 0.6; cursor: default; }
    .row { margin-bottom: 14px; }
    .error {
      color: #fca5a5;
      font-size: 12px;
      margin-top: 4px;
      white-space: pre-wrap;
    }
    small { font-size: 11px; color: #6b7280; }
    #status { font-size: 13px; margin-left: 10px; color: #9ca3af; }
    .header-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 14px;
      font-size: 13px;
    }
    th, td {
      border-bottom: 1px solid #111827;
      padding: 6px 4px;
      vertical-align: top;
    }
    th {
      text-align: left;
      font-weight: 600;
      color: #9ca3af;
      font-size: 12px;
    }
    tr:nth-child(even) td { background: #020617; }
    .index-cell {
      color: #6b7280;
      font-size: 12px;
      width: 40px;
    }
    .filename-cell {
      word-break: break-all;
      font-size: 12px;
      color: #e5e7eb;
    }
    .title-cell { font-weight: 600; font-size: 13px; }
    .keywords-cell {
      font-size: 12px;
      color: #d1d5db;
      white-space: pre-wrap;
    }
    .category-cell { font-size: 12px; color: #e5e7eb; }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #9ca3af;
    }
    .api-keys-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 6px;
      margin-top: 4px;
      max-height: 260px;
      overflow-y: auto;
      padding-right: 4px;
    }
  </style>
</head>
<body>
  <h1>Adobe Stock Metadata & Image Prompt Generator</h1>
  <p class="subtitle">
    Uses Groq <strong>vision model</strong> with up to <strong>50 API keys</strong>.<br>
    Image #1 → Key #1, image #2 → Key #2, … image #50 → Key #50, image #51 → Key #1 again, and so on.
  </p>

  <div class="card">
    <!-- API SETTINGS TOGGLE -->
    <div class="row header-row">
      <div style="display:flex;align-items:center;gap:8px;">
        <button id="toggleApiSettingsBtn" class="secondary">API key settings</button>
        <span class="badge">
          <span style="width:8px;height:8px;border-radius:50%;background:#22c55e;"></span>
          client-side only
        </span>
      </div>
    </div>

    <!-- API SETTINGS PANEL (HIDDEN BY DEFAULT) -->
    <div id="apiSettingsPanel" style="display:none; margin-bottom: 14px; border:1px solid #1f2937; border-radius:10px; padding:10px 12px;">
      <label>Groq API Keys (up to 50)</label>
      <div class="api-keys-grid" id="apiKeysGrid">
        <!-- 50 inputs will be created by JS -->
      </div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;gap:8px;">
        <small>
          Keys are stored only in this browser (localStorage).<br>
          Image 1 uses key 1, image 2 uses key 2, … image 50 uses key 50, image 51 uses key 1 again.
        </small>
        <button id="saveKeysBtn" class="secondary">Save keys</button>
      </div>
      <div id="apiKeyError" class="error"></div>
    </div>

    <!-- MODE -->
    <div class="row">
      <label for="mode">Mode</label>
      <select id="mode">
        <option value="metadata">Adobe Stock Metadata (title + keywords + category)</option>
        <option value="prompt">Image → Prompt (generate detailed text prompt)</option>
      </select>
      <small>
        Metadata mode: title 100–150 words, 30–45 keywords, Adobe Stock category.<br>
        Image → Prompt: generates a long descriptive prompt for the image.
      </small>
    </div>

    <!-- FILE INPUT -->
    <div class="row">
      <label for="imageInput">Select images (up to 500)</label>
      <input type="file" id="imageInput" accept="image/*" multiple />
      <small>Images are sent to Groq as base64. Very huge files might hit Groq’s 4MB base64 limit.</small>
      <div id="fileError" class="error"></div>
    </div>

    <!-- ACTION BUTTONS -->
    <div class="row header-row">
      <div style="display:flex;flex-wrap:wrap;align-items:center;gap:8px;">
        <button id="generateBtn">Generate</button>
        <button id="retryErrorsBtn" class="secondary" disabled>Retry errors</button>
        <span id="status"></span>
        <span id="errorInfo" style="font-size:12px;color:#fca5a5;display:none;">
          Errors: <span id="errorCount">0</span>
        </span>
      </div>
      <button id="downloadCsvBtn" class="secondary" disabled>Download CSV</button>
    </div>

    <div id="globalError" class="error"></div>

    <!-- RESULTS -->
    <div id="resultsSection" style="margin-top: 10px; display:none;">
      <h3 style="font-size:14px; margin: 0 0 6px;">Results</h3>
      <small id="resultsSummary"></small>
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>File</th>
            <th id="headerTitle">Adobe Stock Title / Prompt</th>
            <th id="headerKeywords">Keywords (30–45, metadata mode)</th>
            <th id="headerCategory">Category (metadata mode)</th>
            <th>Error (after all keys tried)</th>
          </tr>
        </thead>
        <tbody id="resultsBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    // Vision model from Groq docs
    const GROQ_MODEL = 'meta-llama/llama-4-scout-17b-16e-instruct';

    const apiSettingsPanel   = document.getElementById('apiSettingsPanel');
    const toggleApiSettingsBtn = document.getElementById('toggleApiSettingsBtn');
    const apiKeysGrid        = document.getElementById('apiKeysGrid');
    const saveKeysBtn        = document.getElementById('saveKeysBtn');
    const apiKeyError        = document.getElementById('apiKeyError');
    const fileInput          = document.getElementById('imageInput');
    const fileError          = document.getElementById('fileError');
    const generateBtn        = document.getElementById('generateBtn');
    const retryErrorsBtn     = document.getElementById('retryErrorsBtn');
    const downloadCsvBtn     = document.getElementById('downloadCsvBtn');
    const statusEl           = document.getElementById('status');
    const globalError        = document.getElementById('globalError');
    const resultsSection     = document.getElementById('resultsSection');
    const resultsSummary     = document.getElementById('resultsSummary');
    const resultsBody        = document.getElementById('resultsBody');
    const errorInfoEl        = document.getElementById('errorInfo');
    const errorCountEl       = document.getElementById('errorCount');
    const modeSelect         = document.getElementById('mode');
    const headerTitle        = document.getElementById('headerTitle');
    const headerKeywords     = document.getElementById('headerKeywords');
    const headerCategory     = document.getElementById('headerCategory');

    // API key inputs (50)
    const apiKeyInputs = [];

    // Store results for CSV
    const results = [];
    let lastMode = 'metadata';

    function setupApiKeyInputs() {
      for (let i = 0; i < 50; i++) {
        const input = document.createElement('input');
        input.type = 'password';
        input.id = 'apiKey' + (i + 1);
        input.placeholder = 'API key ' + (i + 1) + (i === 0 ? ' (required)' : ' (optional)');
        apiKeysGrid.appendChild(input);
        apiKeyInputs.push(input);
      }
    }

    function updateHeadersForMode(mode) {
      if (mode === 'metadata') {
        headerTitle.textContent    = 'Adobe Stock Title';
        headerKeywords.textContent = 'Keywords (30–45)';
        headerCategory.textContent = 'Category';
      } else {
        headerTitle.textContent    = 'Image Prompt';
        headerKeywords.textContent = 'Keywords (N/A in prompt mode)';
        headerCategory.textContent = 'Category (N/A in prompt mode)';
      }
    }

    function getNonEmptyKeys() {
      return apiKeyInputs
        .map(i => i.value.trim())
        .filter(v => v.length > 0);
    }

    function loadSavedKeys() {
      try {
        const raw50 = localStorage.getItem('groq_api_keys_50');
        const raw20 = localStorage.getItem('groq_api_keys_20');
        if (raw50) {
          const list = JSON.parse(raw50);
          list.forEach((val, idx) => {
            if (apiKeyInputs[idx]) apiKeyInputs[idx].value = val || '';
          });
        } else if (raw20) {
          const list = JSON.parse(raw20);
          list.forEach((val, idx) => {
            if (apiKeyInputs[idx]) apiKeyInputs[idx].value = val || '';
          });
        } else {
          const single = localStorage.getItem('groq_api_key');
          if (single && apiKeyInputs[0]) apiKeyInputs[0].value = single;
        }
      } catch (e) {
        console.warn('Could not read localStorage:', e);
      }
    }

    function saveKeys() {
      apiKeyError.textContent = '';
      globalError.textContent = '';
      const values = apiKeyInputs.map(i => i.value.trim());
      if (!values.some(v => v)) {
        apiKeyError.textContent = 'Enter at least one API key before saving.';
        return;
      }
      try {
        localStorage.setItem('groq_api_keys_50', JSON.stringify(values));
        statusEl.textContent = 'API keys saved ✔️';
        setTimeout(() => {
          if (statusEl.textContent === 'API keys saved ✔️') statusEl.textContent = '';
        }, 2000);
      } catch (e) {
        apiKeyError.textContent = 'Could not save keys (localStorage error).';
        console.error(e);
      }
    }

    // Toggle API settings panel
    toggleApiSettingsBtn.addEventListener('click', () => {
      if (apiSettingsPanel.style.display === 'none' || apiSettingsPanel.style.display === '') {
        apiSettingsPanel.style.display = 'block';
      } else {
        apiSettingsPanel.style.display = 'none';
      }
    });

    // Helper: file → base64 (without data: prefix)
    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const result = reader.result || '';
          const base64 = String(result).split(',')[1] || '';
          resolve(base64);
        };
        reader.onerror = () => reject(new Error('Failed to read file: ' + file.name));
        reader.readAsDataURL(file);
      });
    }

    async function generateForSelectedImages() {
      apiKeyError.textContent = '';
      fileError.textContent = '';
      globalError.textContent = '';
      resultsBody.innerHTML = '';
      resultsSummary.textContent = '';
      statusEl.textContent = '';
      results.length = 0;
      downloadCsvBtn.disabled = true;
      retryErrorsBtn.disabled = true;
      errorCountEl.textContent = '0';
      errorInfoEl.style.display = 'none';

      const mode = modeSelect.value;
      lastMode = mode;
      updateHeadersForMode(mode);

      const keys = getNonEmptyKeys();
      if (!keys.length) {
        apiKeyError.textContent = 'Please enter at least one Groq API key.';
        return;
      }

      const files = fileInput.files;
      if (!files || files.length === 0) {
        fileError.textContent = 'Please select at least one image.';
        return;
      }
      if (files.length > 500) {
        fileError.textContent = 'Please select up to 500 images (you selected ' + files.length + ').';
        return;
      }

      generateBtn.disabled = true;
      saveKeysBtn.disabled = true;
      statusEl.textContent = 'Starting...';

      // Show result table immediately so rows appear live as we process
      resultsSection.style.display = 'block';

      let successCount = 0;

      for (let i = 0; i < files.length; i++) {
        const file = files[i];

        let data = null;
        let lastError = null;

        // First attempt uses keyIndex = i % keys.length (1st image -> key1, 2nd -> key2, etc.)
        for (let attempt = 0; attempt < keys.length; attempt++) {
          const keyIndex = (i + attempt) % keys.length;
          const apiKey = keys[keyIndex];

          statusEl.textContent =
            `Processing ${i + 1} / ${files.length} (attempt ${attempt + 1} using key ${keyIndex + 1})…`;

          try {
            data = await generateForImage(apiKey, file, mode);
            lastError = null;
            break; // success
          } catch (err) {
            console.error(`Error with key ${keyIndex + 1} for file ${file.name}`, err);
            lastError = err;
          }
        }

        if (data) {
          successCount++;
          appendResultRow(i, file, data, null, mode);
        } else {
          appendResultRow(i, file, null, lastError, mode);
        }
      }

      generateBtn.disabled = false;
      saveKeysBtn.disabled = false;

      const errorCount = results.filter(r => r && r.error).length;
      errorCountEl.textContent = String(errorCount);
      errorInfoEl.style.display = 'inline';

      resultsSummary.textContent =
        `Generated results for ${successCount} out of ${files.length} images. ` +
        (errorCount > 0 ? `${errorCount} images still have errors.` : 'All images succeeded.');

      if (successCount > 0) {
        downloadCsvBtn.disabled = false;
      }
      retryErrorsBtn.disabled = errorCount === 0;

      statusEl.textContent = 'All images processed ✅';
    }

    async function retryErroredImages() {
      apiKeyError.textContent = '';
      globalError.textContent = '';
      statusEl.textContent = '';

      const mode = lastMode;
      updateHeadersForMode(mode);

      const keys = getNonEmptyKeys();
      if (!keys.length) {
        apiKeyError.textContent = 'Please enter at least one Groq API key.';
        return;
      }

      const files = fileInput.files;
      if (!files || !files.length || !results.length) {
        globalError.textContent = 'Nothing to retry. Generate first.';
        return;
      }

      generateBtn.disabled = true;
      saveKeysBtn.disabled = true;
      retryErrorsBtn.disabled = true;
      downloadCsvBtn.disabled = true;

      let fixedCount = 0;

      for (let i = 0; i < results.length; i++) {
        const record = results[i];
        if (!record || !record.error) continue; // only retry rows with error

        const file = files[i];
        if (!file) continue;

        let data = null;
        let lastError = null;

        for (let attempt = 0; attempt < keys.length; attempt++) {
          const keyIndex = (i + attempt) % keys.length;
          const apiKey = keys[keyIndex];

          statusEl.textContent =
            `Retrying image ${i + 1} (attempt ${attempt + 1} using key ${keyIndex + 1})…`;

          try {
            data = await generateForImage(apiKey, file, mode);
            lastError = null;
            break;
          } catch (err) {
            console.error(`Retry error with key ${keyIndex + 1} for file ${file.name}`, err);
            lastError = err;
          }
        }

        if (data) {
          fixedCount++;
          appendResultRow(i, file, data, null, mode);
        } else {
          appendResultRow(i, file, null, lastError, mode);
        }
      }

      generateBtn.disabled = false;
      saveKeysBtn.disabled = false;

      const successCount = results.filter(r => r && !r.error).length;
      const errorCount   = results.filter(r => r && r.error).length;

      if (successCount > 0) downloadCsvBtn.disabled = false;
      retryErrorsBtn.disabled = errorCount === 0;

      errorCountEl.textContent = String(errorCount);
      errorInfoEl.style.display = 'inline';

      resultsSection.style.display = 'block';
      resultsSummary.textContent =
        `Retry complete. Fixed ${fixedCount} images. ` +
        (errorCount > 0
          ? `${errorCount} images still have errors out of ${results.length}.`
          : 'All images are now successful.');

      statusEl.textContent = 'Retry finished ✅';
    }

    function appendResultRow(index, file, data, error, mode) {
      // Remove existing row for this index if present
      let tr = resultsBody.querySelector(`tr[data-index="${index}"]`);
      if (tr) {
        tr.innerHTML = '';
      } else {
        tr = document.createElement('tr');
        tr.dataset.index = index;
        resultsBody.appendChild(tr);
      }

      const idxTd = document.createElement('td');
      idxTd.textContent = index + 1;
      idxTd.className = 'index-cell';
      tr.appendChild(idxTd);

      const fileTd = document.createElement('td');
      fileTd.className = 'filename-cell';
      fileTd.textContent = file.name;
      tr.appendChild(fileTd);

      const titleTd = document.createElement('td');
      titleTd.className = 'title-cell';

      const keywordsTd = document.createElement('td');
      keywordsTd.className = 'keywords-cell';

      const categoryTd = document.createElement('td');
      categoryTd.className = 'category-cell';

      const errorTd = document.createElement('td');
      errorTd.className = 'error';

      const record = {
        filename: file.name,
        title: '',
        keywords: [],
        category: '',
        prompt: '',
        error: ''
      };

      if (data && !error) {
        if (mode === 'metadata') {
          const title = data.title || '';
          const keywords = Array.isArray(data.keywords) ? data.keywords : [];
          const category = data.category || '';

          titleTd.textContent = title || '(no title)';
          keywordsTd.textContent = keywords.length ? keywords.join(', ') : '(no keywords)';
          categoryTd.textContent = category || '(no category)';
          errorTd.textContent = '';

          record.title = title;
          record.keywords = keywords;
          record.category = category;
        } else {
          const prompt = data.prompt || '';
          titleTd.textContent = prompt || '(no prompt)';
          keywordsTd.textContent = '—';
          categoryTd.textContent = '—';
          errorTd.textContent = '';

          record.prompt = prompt;
        }
      } else {
        titleTd.textContent = '(error)';
        keywordsTd.textContent = '—';
        categoryTd.textContent = '—';
        const msg = (error && error.message) ? error.message : 'Unknown error.';
        errorTd.textContent = msg;
        record.error = msg;
      }

      results[index] = record;
      tr.appendChild(titleTd);
      tr.appendChild(keywordsTd);
      tr.appendChild(categoryTd);
      tr.appendChild(errorTd);
    }

    // Generic Groq VISION call: supports both modes
    async function generateForImage(apiKey, file, mode) {
      const baseName    = file.name.replace(/\.[^.]+$/, '');
      const cleanedName = baseName.replace(/[_-]+/g, ' ').trim();

      const base64  = await fileToBase64(file);
      const mime    = file.type || 'image/jpeg';
      const dataUrl = `data:${mime};base64,${base64}`;

      let systemPrompt;
      let userPrompt;

      if (mode === 'metadata') {
        systemPrompt =
          'You generate metadata specifically for Adobe Stock images.\n' +
          'You receive the actual image plus a short text hint (file name).\n' +
          'Return ONLY valid JSON with this exact shape:\n' +
          '{ "title": string, "keywords": string[], "category": string }\n\n' +
          'Rules:\n' +
          '- Title: English, between 100 and 150 WORDS, very descriptive, 1–2 sentences, no spam or unnatural repetition.\n' +
          '- Keywords: 30–45 relevant English keywords, ordered by importance, no duplicates, no quotes, no numbering.\n' +
          '- Category: a single broad category name like "People", "Nature", "Travel", "Technology", "Business",\n' +
          '  "Food", "Animals", "Architecture", "Sports", "Backgrounds/Textures", etc.\n' +
          '- Do not include any extra text, comments, or code fences. Output the JSON object only.';
        userPrompt =
          `Adobe Stock image file.\n` +
          `Original file name: ${file.name}\n` +
          `Cleaned name: ${cleanedName || '(empty)'}\n\n` +
          `Generate an Adobe Stock-style TITLE (100–150 words), KEYWORDS (30–45), and CATEGORY based on this image.`;
      } else {
        // image → prompt mode
        systemPrompt =
          'You generate detailed text prompts for image generation models based on a given image.\n' +
          'You receive the actual image plus a short text hint (file name).\n' +
          'Return ONLY valid JSON with this exact shape:\n' +
          '{ "prompt": string }\n\n' +
          'Rules:\n' +
          '- Prompt: English, around 80–150 words, natural language, highly descriptive.\n' +
          '- Include subject, environment, lighting, style, camera details if relevant.\n' +
          '- Do not include any extra text, comments, or code fences. Output the JSON object only.';
        userPrompt =
          `Image for prompt generation.\n` +
          `Original file name: ${file.name}\n` +
          `Cleaned name: ${cleanedName || '(empty)'}\n\n` +
          `Generate a single, detailed IMAGE PROMPT (80–150 words) describing this image for a text-to-image model.`;
      }

      const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + apiKey,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: GROQ_MODEL,
          messages: [
            { role: 'system', content: systemPrompt },
            {
              role: 'user',
              content: [
                { type: 'text', text: userPrompt },
                { type: 'image_url', image_url: { url: dataUrl } }
              ]
            }
          ],
          temperature: 0.4,
          top_p: 1,
          stream: false,
          max_completion_tokens: 600,
          response_format: { type: 'json_object' } // JSON mode
        })
      });

      if (!response.ok) {
        const errorText = await response.text().catch(() => '');
        throw new Error('Groq error (' + response.status + '): ' + errorText);
      }

      const data = await response.json();
      const contentText =
        data &&
        data.choices &&
        data.choices[0] &&
        data.choices[0].message &&
        data.choices[0].message.content
          ? data.choices[0].message.content
          : '';

      if (!contentText) {
        throw new Error('Empty response from model.');
      }

      let parsed;
      try {
        parsed = JSON.parse(contentText);
      } catch (e) {
        console.error('Failed to parse JSON from model:', e, contentText);
        throw new Error('Model did not return valid JSON. Raw output: ' + contentText);
      }

      return parsed;
    }

    function escCsv(value) {
      const s = value || '';
      const escaped = s.replace(/"/g, '""');
      return `"${escaped}"`;
    }

    function downloadCsv() {
      if (!results.length) {
        alert('No results to export yet.');
        return;
      }

      const mode = lastMode;

      let header;
      const lines = [];

      if (mode === 'metadata') {
        header = ['Filename', 'Title', 'Keywords', 'Category'];
        lines.push(header.join(','));

        results.forEach(r => {
          if (!r || r.error) return; // skip errored rows
          const keywordsStr = Array.isArray(r.keywords) ? r.keywords.join('; ') : '';
          lines.push([
            escCsv(r.filename),
            escCsv(r.title),
            escCsv(keywordsStr),
            escCsv(r.category)
          ].join(','));
        });
      } else {
        header = ['Filename', 'Prompt'];
        lines.push(header.join(','));

        results.forEach(r => {
          if (!r || r.error) return;
          lines.push([
            escCsv(r.filename),
            escCsv(r.prompt)
          ].join(','));
        });
      }

      const csv = lines.join('\r\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url  = URL.createObjectURL(blob);
      const a    = document.createElement('a');
      a.href = url;
      a.download = (mode === 'metadata')
        ? 'adobe_stock_metadata.csv'
        : 'image_prompts.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ---- bootstrap ----
    setupApiKeyInputs();
    loadSavedKeys();
    updateHeadersForMode(modeSelect.value);

    saveKeysBtn.addEventListener('click', saveKeys);
    generateBtn.addEventListener('click', generateForSelectedImages);
    retryErrorsBtn.addEventListener('click', retryErroredImages);
    downloadCsvBtn.addEventListener('click', downloadCsv);
  </script>
</body>
</html>
